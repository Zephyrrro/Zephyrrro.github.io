<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript中的异步</title>
    <link href="/2020/05/10/JavaScript%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    <url>/2020/05/10/JavaScript%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p class="note note-info">    大概一年前就初步认识到JavaScript在单线程的运行机制下是怎么运行异步代码的，但只是懵懵懂懂，直到最近才大致清楚的了解了整个运行过程...</p><h2 id="单线程的JavaScript"><a href="#单线程的JavaScript" class="headerlink" title="单线程的JavaScript"></a>单线程的JavaScript</h2><p>众所周知 <code>Javascript</code> 是单线程执行的，这就意味着代码只能自顶向下按顺序执行，一旦某行代码运行时间过长，就会导致后续代码运行阻塞。在 <code>JavaScript</code> 诞生的初期，<code>JavaScript</code> 只是用于简单的浏览器交互，并没有考虑到十分复杂的情况，因此即使当时是以单线程方式运行也是完全足够的，但在如今大前端时代下，各类技术横纵向发展迅速<del>(开花警告)</del>，没有异步运行机制显然无法使 <code>JavaScript</code> 胜任如此大的工作量.</p><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>单线程的 <code>JavaScript</code> 只维护一个执行栈。执行栈的运行机制大致如下：</p><ul><li><p>在脚本初次运行时会先在底部推入 <code>Global</code> ，即我们常说的 <code>Global Context(全局执行上下文)</code> ，这一 <code>context</code> 保存着全局变量对象，只有在整个程序运行完毕后才会从执行栈内弹出，此时程序运行结束.</p></li><li><p>当遇到函数时，会向执行栈中推入 <code>Function Context(函数执行上下文)</code>，并开始运行函数内的代码，函数内同样可以调用其他函数，这也同样是一个 <code>Function Context</code> 被推入的过程，直到函数 <code>return</code> 后，该<code>context</code> 弹出.</p></li><li><p>当遇到同步代码时，在代码的 <code>context</code> 下执行并<strong>等待</strong>直至执行完毕；</p></li><li><p>当遇到异步代码时，在代码的 <code>context</code> 下执行并将其<strong>挂起</strong>，同时继续执行后续代码，当异步事件执行完毕后，将其加入<strong>对应</strong>的<strong>事件队列</strong>；</p></li></ul><p><img src="/img/eventloop/The_Javascript_Runtime_Environment_Example.svg" srcset="/img/loading.gif" alt=""></p><h2 id="Eventloop"><a href="#Eventloop" class="headerlink" title="Eventloop"></a>Eventloop</h2><p>上述提到的<strong>事件队列</strong>，就是实现 <code>Event Loop</code> 的关键。执行栈在运行完当前栈内的<strong>全部任务</strong>后，会到<strong>事件队列</strong>中去查找是否存在任务等待执行，如果存在，就会按照队列<strong>先进先出</strong>的特点按顺序执行队列中的事件，执行过程同样遵循上述原则。如此反复，就形成了一个循环(<code>Event Loop</code>)</p><p>可以注意到，事件队列被描述为<strong>对应的</strong>，这意味着不同事件有着自己的队列，队列执行之间自然就存在着优先级，而这些事件大致可以分为两类：宏任务(<code>macro task</code>)、微任务(<code>micro task</code>)；</p><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><table><thead><tr><th>Task</th><th align="center">Broswer</th><th align="center">Node</th></tr></thead><tbody><tr><td><code>I/O</code></td><td align="center">✅</td><td align="center">✅</td></tr><tr><td><code>setTimeOut</code></td><td align="center">✅</td><td align="center">✅</td></tr><tr><td><code>setInterval</code></td><td align="center">✅</td><td align="center">✅</td></tr><tr><td><code>setImmediate</code></td><td align="center">❌</td><td align="center">✅</td></tr><tr><td><code>requestAnimationoFrame</code></td><td align="center">✅</td><td align="center">❌</td></tr></tbody></table><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><table><thead><tr><th>Task</th><th align="center">Broswer</th><th align="center">Node</th></tr></thead><tbody><tr><td><code>process.nextTick</code></td><td align="center">❌</td><td align="center">✅</td></tr><tr><td><code>Promise</code></td><td align="center">✅</td><td align="center">✅</td></tr><tr><td><code>MutationObserver</code></td><td align="center">✅</td><td align="center">❌</td></tr></tbody></table><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><code>process.nextTick</code> &gt; <code>Promise</code> &gt; <code>setTimeout(fn)</code>、<code>setInterval(fn)</code> &gt; <code>setImmediate</code> &gt; <code>setTimeout(fn, time)</code>、<code>setInterval(fn, time)</code>.</p><div class="note note-info">            <p><code>PS:</code>因为 <code>setTimeOut</code>、<code>setInterval</code> 在没有设置 <code>time</code> 参数时，会在主线程最近获得的空闲时间时运行，即尽可能早的运行，因此优先级大于设置 <code>time</code> 参数时</p>          </div><h3 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h3><div class="hljs"><pre><code class="hljs javascript">setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);&#125;, <span class="hljs-number">0</span>);setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);&#125;, <span class="hljs-number">0</span>);<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);  resolve();  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);process.nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">7</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-number">8</span>);</code></pre></div><p>简单画图分析一下，函数开始运行时：</p><p><img src="/img/eventloop/example1-step1.png" srcset="/img/loading.gif" alt=""></p><p>自顶向下运行后，会依次打印出 <code>3 4 6 8</code>，且 <code>setTimeout</code>, <code>setImmediate</code>, <code>nextTick</code>, <code>Promise</code> 队列发生变化(注：<code>Promise</code> 的构造函数是同步过程)，如下图所示：</p><p><img src="/img/eventloop/example1-step2.png" srcset="/img/loading.gif" alt=""></p><p>此时栈清空，全部同步任务完成，检查<strong>事件队列</strong>中是否存在异步事件，并按照优先级和队列特点依次执行(先检查微任务，再检查宏任务)。因此又会依次打印 <code>7 5 2 1</code>.</p><p>此例运行到这里已经结束了，但正常来说会执行完此轮异步任务后，会再检查一次，如果事件队列中存在异步任务(在此轮异步任务执行时被推入队列)，则会重复以上操作，直至事件队列中不再存在异步事件后才会继续执行.</p><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p><code>async/await</code> 是 <code>Promise</code> 的语法糖，它使异步代码更易编写和阅读，因为使用了 <code>async/await</code> 后，代码读起来就像同步代码一般，十分容易理解。</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p><code>async</code> 使函数返回一个 <code>Promise</code>，在调用函数时就能使用 <code>then</code> 链连接后续的操作</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> asyncFun = <span class="hljs-keyword">async</span> () =&gt; &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">'something'</span>;&#125;asyncFun().then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res))<span class="hljs-comment">//=&gt;'something'</span></code></pre></div><p>等价于：</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'something'</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(res))<span class="hljs-comment">//=&gt;'something'</span></code></pre></div><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p><code>await</code> 关键字只能在 <code>async Function</code> 中使用。<code>async Function</code> 运行到有 <code>await</code> 标记的异步函数时，会暂停在此行代码上，直到该异步任务完成，才会执行后续代码，这就使得代码结构与同步代码一般。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promiseFunc = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            resolve(<span class="hljs-string">'after 2s'</span>)        &#125;, <span class="hljs-number">2</span> * <span class="hljs-number">1000</span>)    &#125;)&#125;<span class="hljs-keyword">const</span> asyncFunc = <span class="hljs-keyword">async</span> () =&gt; &#123;    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> promiseFunc();    <span class="hljs-built_in">console</span>.log(res);&#125;asyncFunc()<span class="hljs-comment">//2s后输出 after 2s</span></code></pre></div><h3 id="使用async-await的Eventloop"><a href="#使用async-await的Eventloop" class="headerlink" title="使用async/await的Eventloop"></a>使用async/await的Eventloop</h3><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> async1 = <span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"async1 start"</span>);  <span class="hljs-keyword">await</span> async2();  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"async1 end"</span>);&#125;<span class="hljs-keyword">const</span> async2 = <span class="hljs-keyword">async</span> () =&gt; &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"async2"</span>);&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"script start"</span>);setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"setTimeout"</span>);&#125;, <span class="hljs-number">0</span>);async1();<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"promise1"</span>);  resolve();&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"promise2"</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"script end"</span>);<span class="hljs-comment">/** </span><span class="hljs-comment"> * script start</span><span class="hljs-comment"> * async1 start</span><span class="hljs-comment"> * async2</span><span class="hljs-comment"> * promise1</span><span class="hljs-comment"> * script end</span><span class="hljs-comment"> * promise2</span><span class="hljs-comment"> * async1 end</span><span class="hljs-comment"> * setTimeout</span><span class="hljs-comment">*/</span></code></pre></div><p>其中，<code>async1</code> 等价于</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> async1 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"async1 start"</span>);    <span class="hljs-built_in">Promise</span>.resolve(async2()).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-comment">//async2也是一个返回promise的函数</span>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"async1 end"</span>);    &#125;);    resolve()  &#125;);&#125;;</code></pre></div><p>可以看到 <code>async/await</code> 确实减少了很多代码量.</p><div class="note note-primary">            <div>    参考：    <p>        <a href="https://zhuanlan.zhihu.com/p/33058983" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33058983</a>    </p>    <p>        <a href="https://juejin.im/post/5b73d7a6518825610072b42b#heading-9" target="_blank" rel="noopener">https://juejin.im/post/5b73d7a6518825610072b42b#heading-9</a>    </p>    <p>        <a href="https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/%E5%BC%82%E6%AD%A5/Async_await" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/%E5%BC%82%E6%AD%A5/Async_await</a>    </p></div>              </div>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>异步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DOM Render</title>
    <link href="/2020/05/09/dom-render/"/>
    <url>/2020/05/09/dom-render/</url>
    
    <content type="html"><![CDATA[<div class="note note-secondary">            <p>一道老生常谈的问题：从输入URL到页面展示，经历了哪些过程……</p><p>这里并不全部讨论，来关注一下最后一个过程：浏览器的渲染过程。</p>          </div><p>根据 <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction" target="_blank" rel="noopener">Google Web</a> ，大致可以分为以下五个阶段：</p><ul><li>根据 <code>HTML</code> 生成 <code>DOM Tree</code> (此时并不渲染到页面上)</li><li>根据 <code>CSS</code> 生成对应的 <code>CSSOM Tree</code> (与 <code>DOM Tree</code>上的结点一一对应)</li><li><code>DOM Tree</code> 和 <code>CSSOM Tree</code> 合成生成 <code>Render Tree</code> (不包括 <code>head</code>, <code>meta</code> 等不可见的结点)</li><li><code>Layout</code> 布局渲染</li><li><code>Paint</code> 绘制渲染</li></ul><hr><h2 id="DOM-Tree"><a href="#DOM-Tree" class="headerlink" title="DOM Tree"></a>DOM Tree</h2><p><code>DOM</code>，全称 <code>Document Object Model</code>，是一种对象模型，转化成树的过程为：<code>Bytes → Characters → Tokens → Nodes → DOM</code>.(具体可以跳👉<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model" target="_blank" rel="noopener">constructing-the-object-model</a> )</p><h2 id="CSSOM-Tree"><a href="#CSSOM-Tree" class="headerlink" title="CSSOM Tree"></a>CSSOM Tree</h2><p>同样也是树的结构，同时生成的过程也是对浏览器默认样式的逐步替换。</p><h2 id="Render-Tree"><a href="#Render-Tree" class="headerlink" title="Render Tree"></a>Render Tree</h2><p><code>DOM Tree</code> 和 <code>CSSOM Tree</code> 合并生成 <code>Render Tree</code> (渲染树)</p><p><img src="/img/dom-render/render-tree-construction.png" srcset="/img/loading.gif" alt=""></p><p><code>DOM Tree</code> 从根节点开始遍历每个可见结点(DFS/BFS?)并合并对应 <code>CSSOM</code> 结点中的样式信息。这里的“可见”是指，如果在合并过程中，某个 <code>DOM</code> 结点对应的 <code>CSSOM</code> 结点被设置了 <code>display: none</code> 之类的属性，便会跳过该结点的合并；但 <code>opacity: 0</code>, <code>visible: hidden</code> 这种仍然会占据空间，因此依旧会被合并。(PS：这里就会牵涉到性能问题)</p><h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><p>根据样式信息计算各个结点在设备视区的确切位置以及大小，即 <code>布局</code>.</p><h2 id="Paint"><a href="#Paint" class="headerlink" title="Paint"></a>Paint</h2><p>将各个结点渲染到屏幕的过程。</p><p><img src="/img/dom-render/render-progress.jpg" srcset="/img/loading.gif" alt=""></p><hr><p>我们常说的：尽量避免去操作 <code>DOM</code>，因为成本很高。这里的成本即指时间耗费，也指资源耗费。如果使用 <code>JS</code> 去操作 <code>DOM</code> 和 <code>CSS</code> 时，<code>DOM Tree</code> 和 <code>CSSOM Tree</code> 的内容就会发生变更，从而导致整个渲染过程重复执行，而其中影响最大的就是重新执行 <code>Layout</code> 过程时触发的 <code>reflow(回流)</code> 以及重新执行 <code>Paint</code> 时触发的 <code>repaint(重绘)</code>.</p><h2 id="reflow"><a href="#reflow" class="headerlink" title="reflow"></a>reflow</h2><p>当发生以下情形时会触发 <code>reflow</code> 回流：</p><ul><li>初始渲染时</li><li><code>DOM Tree</code> 结构发生变化时</li><li><code>Render Tree</code> 结构发生变化时</li><li>浏览器 <code>resize</code> 时</li></ul><p>从上面的过程来看，<code>Layout</code> 在 <code>Paint</code> 之前，因此每次触发 <code>reflow</code> 都会导致整个页面的重新渲染。</p><h2 id="repaint"><a href="#repaint" class="headerlink" title="repaint"></a>repaint</h2><p>当发生以下情形时会触发 <code>repaint</code> 重绘：</p><ul><li>触发 <code>reflow</code> 时</li><li>结点的 <code>background-color</code>, <code>color</code>等不影响其周围和内部布局的属性改变时</li></ul><p>应注意 <code>repaint</code> 可以单独触发，且只会影响到属性改变的结点，不会影响到其他结点。</p><div class="note note-info">            <p>从上面的描述很容易发现， <code>reflow</code> 的成本远高于 <code>repaint</code>，从性能优化上看，应该尽量减少 <code>reflow</code> 次数，例如</p><ul><li>先将需要多次修改的 <code>DOM</code> 设置为 <code>display: none</code>，待操作完毕后再显示。(修改不在 <code>Render Tree</code> 上的结点并不会触发 <code>reflow</code> 和 <code>repaint</code> )</li><li>使结点脱离文档流</li></ul>          </div><hr><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>👉<a href="https://muyiy.cn/question/css/57.html" target="_blank" rel="noopener"><code>display: none, visible: hidden, opacity: 0的优劣、区别</code></a></p><p class="note note-primary">参考： <a href="https://juejin.im/entry/59e1d31f51882578c3411c77" target="_blank" rel="noopener">https://juejin.im/entry/59e1d31f51882578c3411c77</a> </p>]]></content>
    
    
    
    <tags>
      
      <tag>DOM</tag>
      
      <tag>brower</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue深入</title>
    <link href="/2019/08/17/Vue-Explore/"/>
    <url>/2019/08/17/Vue-Explore/</url>
    
    <content type="html"><![CDATA[<h2 id="2019-08-17记录"><a href="#2019-08-17记录" class="headerlink" title="2019-08-17记录"></a>2019-08-17记录</h2><h4 id="watch属性深入"><a href="#watch属性深入" class="headerlink" title="watch属性深入"></a>watch属性深入</h4><p>先放一段代码</p><div class="hljs"><pre><code class="hljs javascript">data: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&#123;    obj: &#123;        name: <span class="hljs-string">'cucu6'</span>,        age: <span class="hljs-number">9999</span>    &#125;,    example: <span class="hljs-string">''</span>&#125;)watch: &#123;    obj: &#123;        handler: <span class="hljs-string">'handleObj'</span>,        immediate: <span class="hljs-literal">true</span>, <span class="hljs-comment">// false</span>        deep: <span class="hljs-literal">true</span> <span class="hljs-comment">// false</span>    &#125;&#125;methods: &#123;    handleObj() &#123;        <span class="hljs-comment">/* Do Something... */</span>    &#125;&#125;</code></pre></div><p>上面可以看到，watch属性中不像官网基础教程中给出的那样，只写了一个回调函数，而是有多个键值对，起不同作用。</p><ul><li><p><code>handler</code></p><p><code>handler</code>属性中存放回调函数，一旦侦听的值<code>obj</code>发生改变（被直接赋值），就会触发回调函数；</p><p>需要注意的是，<code>handler</code>的值可以是一个函数（<code>function(newVal, oldVal)</code>)，也可以是写在<code>methods</code>中的方法名，但写成函数形式时应避免使用箭头函数，因为箭头函数绑定了父级作用域的上下文，逻辑上的<code>this</code>指针并不会像往常一样指向整个<code>Vue</code>实例，因此如果在函数里使用<code>this</code>指针时会导致出错，如在回调函数中写<code>this.example = &#39;whatever&#39;</code>，这样是不可用的；</p><p>此外，看官网中的<code>handler</code>也支持函数的数组，但没有尝试过，以后有时间看看。</p></li><li><p><code>immediate</code></p><p><code>immediate</code>属性的值默认为<code>false</code>，当值为<code>true</code>时，在数据被绑定后会立即执行一次回调函数，即在组件渲染后会执行一次<code>handler</code>中的函数，这个应该没什么好讲的。</p></li><li><p><code>deep</code></p><p><code>deep</code>属性据官网介绍：<em>回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深</em></p><p>从表面上看，当我们改变<code>obj.name</code>的值时，<code>handler</code>的回调函数会被执行，其实不然，<code>watch</code>属性侦听对象是监听其引用的变化，也就是说，如果我们不对其进行直接赋值，<code>handler</code>是不会执行的；</p><p>当<code>deep</code>的值为<code>true</code>时，如官网上所描述的，监听器会一层层往下遍历，当某一键值对改变时就会触发回调；</p><p>当然，对每个属性进行监听的性能开销也会增大，此时可以使用<code>string</code>的形式进行侦听。</p><div class="hljs"><pre><code class="hljs javascript">watch: &#123;<span class="hljs-string">'obj.name'</span>: &#123;handler: <span class="hljs-string">'handleObj'</span>,<span class="hljs-comment">/* ... */</span>&#125;&#125;</code></pre></div><p>这样当<code>obj.name</code>发生改变时就会触发回调。</p></li><li><p><code>watch</code>侦听器的注销</p><p>一般<code>watch</code>属性直接写在组件中，会随着组件的销毁而销毁侦听器；而根据 Google，有这样一个方法可以实现监听和销毁；</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> watchDestructer = app.$watch(watchAttribute: string, <span class="hljs-attr">callback</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newVal, oldVal</span>));</span><span class="hljs-function"><span class="hljs-title">watchDestructer</span>(<span class="hljs-params"></span>); // 销毁<span class="hljs-title">watch</span></span></code></pre></div><p><code>app.$watch</code>的返回值是对应属性的注销方法，执行后就能注销侦听。</p></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环境配置记录</title>
    <link href="/2019/08/11/environment-config/"/>
    <url>/2019/08/11/environment-config/</url>
    
    <content type="html"><![CDATA[<h2 id="2019-8-11-更新"><a href="#2019-8-11-更新" class="headerlink" title="2019-8-11 更新"></a>2019-8-11 更新</h2><h4 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h4><h6 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h6><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 配置用户名和邮箱</span>$ git config --global user.name <span class="hljs-string">"test"</span>$ git config --global user.email <span class="hljs-string">"test@test.com"</span></code></pre></div><h6 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h6><p><em>此配置在  C:\Users\User\ 下进行</em></p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment">## 生成ssh</span>$ ssh-keygen -t rsa -C <span class="hljs-string">"test@test.com"</span><span class="hljs-comment"># 不断回车后得到 id_rsa 和 id_rsa.pub</span><span class="hljs-comment"># 添加SSH到ssh-agent</span>$ <span class="hljs-built_in">eval</span> <span class="hljs-string">"<span class="hljs-variable">$(ssh-agent -s)</span>"</span>$ ssh-add ~/.ssh/id_rsa</code></pre></div><p>进入 <em>C:\Users\User\ .ssh</em> ，复制 <em>id_rsa.pub</em> 的内容后，登录 Github</p><p><img src="https://i.loli.net/2019/08/12/ciaStEl1efT3kHb.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://i.loli.net/2019/08/12/5elwc2VOfDI6naH.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://i.loli.net/2019/08/12/bRDJWBgEtaoY3dp.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://i.loli.net/2019/08/12/SDMhdboigqw9458.png" srcset="/img/loading.gif" alt=""></p><p>完成后测试：</p><div class="hljs"><pre><code class="hljs bash">$ ssh -T git@github.com<span class="hljs-comment"># 若出现 Are you sure you want to continue connecting (yes/no)? 输入 yes</span></code></pre></div><p><img src="https://i.loli.net/2019/08/12/EuiXwp6N738aBQ2.png" srcset="/img/loading.gif" alt=""></p><p>自此完成。</p><hr>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
